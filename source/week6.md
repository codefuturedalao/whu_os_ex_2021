# week6

## 实验内容

1. 汇编和C的互相调用方法

   在例程基础上，在汇编与C程序中各添加一个简单带参数的函数调用，让两种语言撰写的程序实现混合调用，功能可自定义。

2. ELF文件格式

   依照书上方法，分析你修改的这个可执行文件

3. 使用Loader加载ELF文件

4. 如何加载并扩展内核

5. 设计题：修改启动代码，在引导过程中在屏幕上画出一个你喜欢的ASCII图案，并将第三章的内存管理功能代码、你自己设计的中断代码集成到你的kernel文件目录管理中，并建立makefile文件，编译成内核，并引导

## 实验问题

1. 汇编和C的调用方法是怎样的？

2. 描述ELF文件格式以及作用

3. 描述从Loader引导ELF的原理

4. 一个内核要能基本使用应该扩展哪些功能，怎么扩展？

5. 怎么管理内核文件目录？

## 实验步骤

## FAQ

### Q: 出现undefined reference to `__stack_chk_fail`错误，如何解决？

需要在 `Makefile` 中的 `$(CFLAGS)` 后面加上 `-fno-stack-protector`，即不需要栈保护

### Q：出现xxx is incompatible with i386:x86-64 output

有些同学的Ubuntu系统是64位，而不是32位，那么gcc默认编译的目标文件是64位，无法和32位汇编文件汇编出的目标文件进行链接，需要在Makefile的CFLAGS后面添加```-m32```，LDFLAGS后面添加```-m elf_i386 ```

### Q：如何方便的在标号声明处和定义处进行跳转。

由于建立了文件目录，浏览代码时不容易查找标号对应的定义，对于使用vim的同学，推荐使用ctags工具，方便标号声明和定义的跳转，对于仍在使用自带编辑器的同学，可以尝试vscode。

```{admonition} 提示

当你阅读到chapter5/f/start.c时，请留意memcpy第一个参数，尝试修改将gdt前面的&符号去掉，查看结果是否一致并思考为什么，这同时会帮助你理解在C语言中声明指针和数组后，在汇编语言中想要使用它们时有什么不同

```
